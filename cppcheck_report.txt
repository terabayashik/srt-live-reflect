src/URI.h:35:5: style: Class 'URI' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    URI(const std::string& uri) { Parse(uri); }
    ^
src/URI.cpp:282:29: style: Redundant condition: If 'EXPR == '\0'', the comparison 'EXPR != ':'' is always true. [redundantCondition]
            if (*cc == '\0' || *cc != ':') return;
                            ^
src/URI.cpp:619:53: style:inconclusive: Function 'operator()' argument 1 names different: declaration 'l' definition 'lhs'. [funcArgNamesDifferent]
bool URIOption::comp::operator()(const std::string& lhs, const std::string& rhs) const {
                                                    ^
src/URI.h:63:54: note: Function 'operator()' argument 1 names different: declaration 'l' definition 'lhs'.
    struct comp { bool operator()(const std::string& l, const std::string& r) const; };
                                                     ^
src/URI.cpp:619:53: note: Function 'operator()' argument 1 names different: declaration 'l' definition 'lhs'.
bool URIOption::comp::operator()(const std::string& lhs, const std::string& rhs) const {
                                                    ^
src/URI.cpp:619:77: style:inconclusive: Function 'operator()' argument 2 names different: declaration 'r' definition 'rhs'. [funcArgNamesDifferent]
bool URIOption::comp::operator()(const std::string& lhs, const std::string& rhs) const {
                                                                            ^
src/URI.h:63:76: note: Function 'operator()' argument 2 names different: declaration 'r' definition 'rhs'.
    struct comp { bool operator()(const std::string& l, const std::string& r) const; };
                                                                           ^
src/URI.cpp:619:77: note: Function 'operator()' argument 2 names different: declaration 'r' definition 'rhs'.
bool URIOption::comp::operator()(const std::string& lhs, const std::string& rhs) const {
                                                                            ^
src/URI.cpp:612:53: performance: Searching before insertion is not necessary. [stlFindInsert]
    if (map_.find(key) == map_.end()) map_[key] = it->second;
                                                    ^
src/json.h:33:5: style: Class 'Json' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Json(const Node& node) : boost::json::value(node.value()) {}
    ^
src/json.h:14:9: style: Class 'Node' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Node(boost::json::value* value) : path_(), root_(value), value_(value) {}
        ^
src/aws.cpp:260:5: style: Class 'Impl' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Impl(const Aws::Client::ClientConfiguration& clientConfig)
    ^
src/aws.cpp:277:60: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            for (Aws::S3::Model::Bucket& b : buckets) list.push_back(b.GetName());
                                                           ^
src/aws.cpp:417:5: error: va_list 'ap2' was opened but not closed by va_end(). [va_end_missing]
    }
    ^
src/curl.cpp:206:12: warning: Member variable 'CurlStrIO::error_' is not initialized in the constructor. [uninitMemberVar]
CurlStrIO::CurlStrIO(Curl curl)
           ^
src/curl.cpp:88:5: performance: Variable 'curl_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
    curl_ = rhs.curl_;
    ^
src/curl.h:70:5: style: Class 'CurlStrIO' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    CurlStrIO(Curl curl);
    ^
src/curl.h:95:5: style: Class 'CurlJsonIO' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    CurlJsonIO(Curl curl);
    ^
src/curl.cpp:201:1: error: va_list 'ap2' was opened but not closed by va_end(). [va_end_missing]
}
^
src/curl.cpp:148:0: information: Skipping configuration 'TCP_KEEPIDLE' since the value of 'TCP_KEEPIDLE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                setsockopt(curlfd, IPPROTO_TCP, TCP_KEEPIDLE, reinterpret_cast<const char*>(&keepidle_), sizeof(keepidle_));
^
src/curl.cpp:151:0: information: Skipping configuration 'TCP_KEEPINTVL' since the value of 'TCP_KEEPINTVL' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
                setsockopt(curlfd, IPPROTO_TCP, TCP_KEEPINTVL, reinterpret_cast<const char*>(&keepintvl_), sizeof(keepintvl_));
^
src/json.cpp:134:22: style:inconclusive: Technically the member function 'to::TO_W::operator()' can be const. [functionConst]
        std::wstring operator()(const char* src, int cp) {
                     ^
src/json.cpp:144:21: style:inconclusive: Technically the member function 'to::TO_A::operator()' can be const. [functionConst]
        std::string operator()(const wchar_t* src, int cp) {
                    ^
src/listener.h:13:5: style: Class 'Listener' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Listener(const ListenOption& listenOption);
    ^
src/messages.h:27:9: style: Class 'Resize' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Resize(size_t resize) : resize_(resize) {}
        ^
src/messages.h:21:27: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual Messages& operator()(Messages& msgs); // clear messages
                          ^
src/messages.h:16:27: note: Virtual function in base class
        virtual Messages& operator()(Messages& msgs) = 0;
                          ^
src/messages.h:21:27: note: Function in derived class
        virtual Messages& operator()(Messages& msgs); // clear messages
                          ^
src/messages.h:28:27: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual Messages& operator()(Messages& msgs); // modify number of messages to keep
                          ^
src/messages.h:16:27: note: Virtual function in base class
        virtual Messages& operator()(Messages& msgs) = 0;
                          ^
src/messages.h:28:27: note: Function in derived class
        virtual Messages& operator()(Messages& msgs); // modify number of messages to keep
                          ^
src/messages.h:46:23: style: The function 'operator<<' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual Messages& operator<<(const std::string& str) { boost::mutex::scoped_lock lk(mutex_); return Messages::operator<<(str); }
                      ^
src/messages.h:31:23: note: Virtual function in base class
    virtual Messages& operator<<(const std::string& str);
                      ^
src/messages.h:46:23: note: Function in derived class
    virtual Messages& operator<<(const std::string& str) { boost::mutex::scoped_lock lk(mutex_); return Messages::operator<<(str); }
                      ^
src/messages.h:47:23: style: The function 'operator<<' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual Messages& operator<<(const boost::format& fmt) { boost::mutex::scoped_lock lk(mutex_); return Messages::operator<<(fmt.str()); }
                      ^
src/messages.h:32:23: note: Virtual function in base class
    virtual Messages& operator<<(const boost::format& fmt) { return operator<<(fmt.str()); }
                      ^
src/messages.h:47:23: note: Function in derived class
    virtual Messages& operator<<(const boost::format& fmt) { boost::mutex::scoped_lock lk(mutex_); return Messages::operator<<(fmt.str()); }
                      ^
src/messages.h:48:23: style: The function 'operator<<' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual Messages& operator<<(Ctrl& ctrl) { boost::mutex::scoped_lock lk(mutex_); return Messages::operator<<(ctrl); }
                      ^
src/messages.h:33:23: note: Virtual function in base class
    virtual Messages& operator<<(Ctrl& ctrl) { return ctrl(*this); }
                      ^
src/messages.h:48:23: note: Function in derived class
    virtual Messages& operator<<(Ctrl& ctrl) { boost::mutex::scoped_lock lk(mutex_); return Messages::operator<<(ctrl); }
                      ^
src/messages.h:49:25: style: The function 'operator()' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual std::string operator()(const std::string& sep = "\n") const { boost::mutex::scoped_lock lk(mutex_); return Messages::operator()(sep); }
                        ^
src/messages.h:34:25: note: Virtual function in base class
    virtual std::string operator()(const std::string& sep = "\n") const;
                        ^
src/messages.h:49:25: note: Function in derived class
    virtual std::string operator()(const std::string& sep = "\n") const { boost::mutex::scoped_lock lk(mutex_); return Messages::operator()(sep); }
                        ^
src/looprec.cpp:572:9: style: Class 'CloseWriterTask' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        CloseWriterTask(LoopRec::Impl* pimpl) : pimpl_(pimpl) {
        ^
src/looprec.cpp:359:65: warning: Either the condition 'buf.empty()' is redundant or expression 'buf.at(0)' cause access out of bounds. [containerOutOfBounds]
        buf.resize(static_cast<size_t>(dat_stream_->read(&buf.at(0), buf.size()).gcount()));
                                                                ^
src/looprec.cpp:364:22: note: Assuming that condition 'buf.empty()' is not redundant
        if (buf.empty()) {
                     ^
src/looprec.cpp:359:65: note: Access out of bounds
        buf.resize(static_cast<size_t>(dat_stream_->read(&buf.at(0), buf.size()).gcount()));
                                                                ^
src/main.cpp:25:9: performance: Variable 'app_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        app_ = option.Get<std::string>("app");
        ^
src/main.cpp:26:9: performance: Variable 'name_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        name_ = option.Get<std::string>("name");
        ^
src/main.cpp:27:9: performance: Variable 'peer_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        peer_ = option.Get<std::string>("peer");
        ^
src/main.cpp:80:5: style: Class 'Reflect' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Reflect(const Json& conf) : Event(), conf_(conf), cache_(), listener_(), receivers_(), loopRecs_(), mutex_(), stats_(0), stats_time_() {
    ^
src/main.cpp:342:5: style: Class 'App' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    App(const std::string& version) : name_("srt-live-reflect"), version_(version), conf_(), reflects_() {
    ^
src/main.cpp:388:13: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
            if (!AWS::Init(conf_)) {
            ^
src/main.cpp:420:55: style: Local variable 'it' shadows outer variable [shadowVariable]
                for (URIOption::map_t::const_iterator it = map.begin(); it != map.end(); ++it) {
                                                      ^
src/main.cpp:411:47: note: Shadowed declaration
            for (Json::keys_t::const_iterator it = keys.begin(); it != keys.end(); ++it) {
                                              ^
src/main.cpp:420:55: note: Shadow variable
                for (URIOption::map_t::const_iterator it = map.begin(); it != map.end(); ++it) {
                                                      ^
src/main.cpp:432:0: information: Skipping configuration 'SIGBREAK' since the value of 'SIGBREAK' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
        std::signal(SIGBREAK, &App::signalHandler);
^
src/receiver.cpp:351:64: style:inconclusive: Function 'Create' argument 2 names different: declaration 'receiveOption' definition 'option'. [funcArgNamesDifferent]
Receiver::ptr_t Receiver::Create(int sfd, const ReceiveOption& option) {
                                                               ^
src/receiver.h:17:55: note: Function 'Create' argument 2 names different: declaration 'receiveOption' definition 'option'.
    static ptr_t Create(int sfd, const ReceiveOption& receiveOption);
                                                      ^
src/receiver.cpp:351:64: note: Function 'Create' argument 2 names different: declaration 'receiveOption' definition 'option'.
Receiver::ptr_t Receiver::Create(int sfd, const ReceiveOption& option) {
                                                               ^
src/receiver.cpp:354:50: style:inconclusive: Function 'Receiver' argument 2 names different: declaration 'receiveOption' definition 'option'. [funcArgNamesDifferent]
Receiver::Receiver(int sfd, const ReceiveOption& option)
                                                 ^
src/receiver.h:13:44: note: Function 'Receiver' argument 2 names different: declaration 'receiveOption' definition 'option'.
    Receiver(int sfd, const ReceiveOption& receiveOption);
                                           ^
src/receiver.cpp:354:50: note: Function 'Receiver' argument 2 names different: declaration 'receiveOption' definition 'option'.
Receiver::Receiver(int sfd, const ReceiveOption& option)
                                                 ^
src/receiver.cpp:252:16: performance: Ineffective call of function 'substr' because it returns a copy of the object. Use operator= instead. [uselessCallsSubstr]
        return s.substr(0, s.length() > sep.length() ? s.length() - sep.length() : std::string::npos);
               ^
src/sender.cpp:222:16: performance: Ineffective call of function 'substr' because it returns a copy of the object. Use operator= instead. [uselessCallsSubstr]
        return s.substr(0, s.length() > sep.length() ? s.length() - sep.length() : std::string::npos);
               ^
src/aws.cpp:154:1: error: The one definition rule is violated, different classes/structs have the same name 'Impl' [ctuOneDefinitionRuleViolation]
class AWS::S3Get::Impl : public S3Async {
^
src/aws.cpp:213:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class AWS::S3Put::Impl : public S3Async {
^
src/aws.cpp:154:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class AWS::S3Get::Impl : public S3Async {
^
src/aws.cpp:154:1: error: The one definition rule is violated, different classes/structs have the same name 'Impl' [ctuOneDefinitionRuleViolation]
class AWS::S3Get::Impl : public S3Async {
^
src/aws.cpp:256:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class AWS::S3Client::Impl {
^
src/aws.cpp:154:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class AWS::S3Get::Impl : public S3Async {
^
src/aws.cpp:154:1: error: The one definition rule is violated, different classes/structs have the same name 'Impl' [ctuOneDefinitionRuleViolation]
class AWS::S3Get::Impl : public S3Async {
^
src/listener.cpp:8:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class Listener::Impl
^
src/aws.cpp:154:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class AWS::S3Get::Impl : public S3Async {
^
src/aws.cpp:154:1: error: The one definition rule is violated, different classes/structs have the same name 'Impl' [ctuOneDefinitionRuleViolation]
class AWS::S3Get::Impl : public S3Async {
^
src/looprec.cpp:426:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class LoopRec::Impl
^
src/aws.cpp:154:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class AWS::S3Get::Impl : public S3Async {
^
src/aws.cpp:154:1: error: The one definition rule is violated, different classes/structs have the same name 'Impl' [ctuOneDefinitionRuleViolation]
class AWS::S3Get::Impl : public S3Async {
^
src/receiver.cpp:8:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class Receiver::Impl
^
src/aws.cpp:154:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class AWS::S3Get::Impl : public S3Async {
^
src/aws.cpp:154:1: error: The one definition rule is violated, different classes/structs have the same name 'Impl' [ctuOneDefinitionRuleViolation]
class AWS::S3Get::Impl : public S3Async {
^
src/sender.cpp:8:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class Sender::Impl
^
src/aws.cpp:154:1: note: The one definition rule is violated, different classes/structs have the same name 'Impl'
class AWS::S3Get::Impl : public S3Async {
^
src/URI.cpp:414:0: style: The function 'Encode' is never used. [unusedFunction]

^
src/URI.cpp:534:0: style: The function 'Erase' is never used. [unusedFunction]

^
src/logger.cpp:124:0: style: The function 'ErrorEnabled' is never used. [unusedFunction]

^
src/logger.cpp:128:0: style: The function 'FatalEnabled' is never used. [unusedFunction]

^
src/aws.cpp:396:0: style: The function 'GetLogLevel' is never used. [unusedFunction]

^
src/sockaddr.cpp:143:0: style: The function 'GetPeerName' is never used. [unusedFunction]

^
src/sockaddr.cpp:122:0: style: The function 'GetPort' is never used. [unusedFunction]

^
src/sockaddr.cpp:135:0: style: The function 'GetSockName' is never used. [unusedFunction]

^
src/logger.cpp:116:0: style: The function 'InfoEnabled' is never used. [unusedFunction]

^
src/URI.cpp:362:0: style: The function 'IsIPv4Addr' is never used. [unusedFunction]

^
src/aws.cpp:399:0: style: The function 'Log' is never used. [unusedFunction]

^
src/curl.cpp:37:0: style: The function 'SetDefaultTimeout' is never used. [unusedFunction]

^
src/aws.cpp:66:0: style: The function 'Test' is never used. [unusedFunction]

^
src/logger.cpp:120:0: style: The function 'WarningEnabled' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingIncludeSystem]

